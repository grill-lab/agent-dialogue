package edu.gla.kail.ad.core;

import com.google.cloud.Tuple;
import com.google.protobuf.Timestamp;
import edu.gla.kail.ad.Client.InputInteraction;
import edu.gla.kail.ad.Client.InteractionRequest;
import edu.gla.kail.ad.Client.InteractionResponse;
import edu.gla.kail.ad.Client.InteractionType;
import edu.gla.kail.ad.Client.OutputInteraction;
import edu.gla.kail.ad.core.Log.RequestLog;
import edu.gla.kail.ad.core.Log.ResponseLog;
import edu.gla.kail.ad.core.Log.ResponseLog.MessageStatus;
import io.reactivex.Observable;
import io.reactivex.schedulers.Schedulers;

import java.io.IOException;
import java.time.Instant;
import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

import static com.google.common.base.Preconditions.checkNotNull;

/**
 * The manager is configured to have conversations with specified agents (of certain agent type,
 * * e.g. Dialogflow or Alexa).
 * Conversation management includes handling session state, including starting sessions (assigning
 * session IDs), as well as request identifiers. It also handles serialization of conversation log
 * data.
 *
 * Instruction of usage:
 * 1) Set up the Dialog agents using setUpAgents method.
 * 2) Call the getResponseFromAgent for required inputs.
 * 3) Use ranking method. TODO(Adam): further part needs to be implemented
 *
 * Example usage :
 * DialogAgentManager dialogAgentManager = new DialogAgentManager();
 * dialogAgentManager.setUpAgents(_configurationTuples);
 * dialogAgentManager.getResponsesFromAgents(interactionRequest);
 **/

public class DialogAgentManager {
    // List of instances of used Dialog agents.
    private List<AgentInterface> _agents;
    // Session ID is a unique identifier of a session which is assigned by the method
    // startSession() called by DialogAgentManager constructor.
    private String _sessionId;

    /**
     * Create a unique session ID generated with startSession() method.
     */
    public DialogAgentManager() {
        startSession();
    }

    /**
     * Method used for testing the server.
     * TODO(Adam): Delete after testing is done.
     *
     * @param interactionRequest - interactionRequest sent by the client.
     * @return interactionResponse - dummy instance of InteractionResponse created for testing
     *         output.
     */
    public InteractionResponse getResponseFromAgentAsInteractionResponse(InteractionRequest
                                                                                 interactionRequest) {
        InteractionResponse interactionResponse = InteractionResponse.newBuilder()
                .setResponseId("Setting response Id was successful")
                .setTime(Timestamp.newBuilder()
                        .setSeconds(Instant.now()
                                .getEpochSecond())
                        .setNanos(Instant.now()
                                .getNano())
                        .build())
                .setClientId("Setting Client Id was successful")
                .addInteraction(OutputInteraction.newBuilder()
                        .setType(InteractionType.TEXT)
                        .setText("Setting OutputInteraction text was succrssful")
                        .addAction("Adding OutputInteraction Action was successful")
                        .build())
                .build();
        return interactionResponse;
    }

    /**
     * Create a unique sessionId.
     */
    private void startSession() {
        _sessionId = getRandomID();
    }

    public void endSession() {
        // TODO(Adam): Creation of configuration file - to be done later on.
        // TODO(Adam): Updating/Saving to the log file?
    }

    /**
     * Creates random ID used for session ID and request ID.
     *
     * @return String - A random ID consisting of timestamp and a random id generated by UUID.
     */
    private String getRandomID() {
        return (new java.sql.Timestamp(System.currentTimeMillis())).toString() + UUID.randomUUID
                ().toString();
    }

    /**
     * Set up (e.g. authenticate) all agents and store them to the list of agents.
     *
     * @param configurationTuples - The list stores the entities of ConfigurationTuple,
     *         which holds data required by each agent.
     * @throws IllegalArgumentException - Raised by _agents.add(new
     *         DialogflowAgent(_sessionId, agentSpecificData.get(0)));
     * @throws IOException, IllegalArgumentException
     */
    public void setUpAgents(List<ConfigurationTuple> configurationTuples) throws
            IllegalArgumentException, IOException {
        _agents = new ArrayList();
        for (ConfigurationTuple configurationTuple : configurationTuples) {
            switch (configurationTuple.get_agentType()) {
                case DIALOGFLOW:
                    List<Tuple> agentSpecificData = checkNotNull(configurationTuple
                            .get_agentSpecificData(), "The Dialogflow specific data is null!");
                    if (agentSpecificData.size() != 1) {
                        throw new IllegalArgumentException("The Dialogflow agent specific data " +
                                "passed is not valid for Dialogflow! It has to be project ID and " +
                                "Service Account key file directory.");
                    }
                    _agents.add(new DialogflowAgent(_sessionId, agentSpecificData.get(0)));
                    break;
                case DUMMYAGENT:
                    _agents.add(new DummyAgent());
                    break;
                default:
                    throw new IllegalArgumentException("The type of the agent provided " +
                            "\"" +
                            configurationTuple
                                    .get_agentType() + "\" is not currently supported " +
                            "(yet)!");
            }
        }
    }

    /**
     * Get Request from Client and convert it to the RequestLog.
     * Return the list of responses for a given request.
     * TODO(Adam): Maybe store the logs after each conversation; need to decide later on.
     *
     * @param interactionRequest - The a data structure (implemented in log.proto) holding
     *         the interaction from a client.
     * @return List<ResponseLog> - The list of responses of all agents set up on the
     *         setUpAgents(...) method call.
     * @throws IllegalArgumentException, Exception
     */
    public List<ResponseLog> getResponsesFromAgents(InteractionRequest interactionRequest) throws
            IllegalArgumentException, Exception {
        if (checkNotNull(_agents, "Agents are not set up! Use the method" +
                " setUpAgents() first.").isEmpty()) {
            throw new IllegalArgumentException("The list of agents is empty!");
        }

        Timestamp timestamp = Timestamp.newBuilder()
                .setSeconds(Instant.now()
                        .getEpochSecond())
                .setNanos(Instant.now()
                        .getNano())
                .build();

        // Save data from InteractionRequest to RequestLog.
        RequestLog requestLog = RequestLog.newBuilder()
                .setRequestId(getRandomID())
                .setTime(timestamp)
                .setClientId(interactionRequest.getClientId())
                .setInteraction(interactionRequest.getInteraction()).build();

        InputInteraction inputInteraction = requestLog.getInteraction();

        // Get responses the agents using RxJava asynchronously.
        Observable<AgentInterface> agentInterfaceObservable = Observable.fromIterable(_agents);
        List<ResponseLog> listOfResponseLogs = (agentInterfaceObservable.flatMap(agentObservable
                -> Observable
                .just(agentObservable)
                .subscribeOn(Schedulers.computation())
                .map(agent -> {
                    try {
                        return agent.getResponseFromAgent(inputInteraction);
                    } catch (Exception exception) {
                        return ResponseLog.newBuilder()
                                .setMessageStatus(MessageStatus.UNSUCCESFUL)
                                .setErrorMessage(exception.getMessage())
                                .build();
                    }
                })
        ).toList().blockingGet());

        // TODO(Adam) Remove when the log saving is implemented. Currently we can see the output.
        listOfResponseLogs.forEach(System.out::println);
        return listOfResponseLogs;
    }

    public ResponseLog chooseOneResponse(List<ResponseLog> responses) throws Exception {
        if (checkNotNull(responses, "The list passed to the chooseOneResponse function is not " +
                "initialized!").isEmpty()) {
            throw new IllegalArgumentException("The list of responses is empty!");
        }
        return chooseFirstValidResponse(responses);
    }

    public ResponseLog chooseFirstValidResponse(List<ResponseLog> responses) throws Exception {
        for (ResponseLog responseLog : responses) {
            if (responseLog.getMessageStatus() == MessageStatus.SUCCESSFUL) {
                return responseLog;
            }
        }
        throw new Exception("Non of the passed responses had a successful call to the agent.");
    }

    // TODO(Adam): store the conversation in the log as a single Turn
}